<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>S I M O N ∴ R E B O R N</title>
    <style>
        /* --- CSS & UI STYLING --- */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Orbitron', sans-serif; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to Three.js */
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 10;
        }

        .hud-text {
            color: rgba(255, 255, 255, 0.9); text-align: center; text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            pointer-events: auto; transition: opacity 0.5s ease;
        }

        h1 {
            font-size: 5rem; letter-spacing: 1rem; margin: 0;
            background: linear-gradient(90deg, #0ff, #f0f, #ff0); -webkit-background-clip: text; color: transparent;
            animation: glitch 3s infinite alternate;
        }

        .btn {
            margin-top: 2rem; padding: 15px 40px; font-size: 1.5rem; background: transparent;
            border: 2px solid #0ff; color: #0ff; cursor: pointer; text-transform: uppercase; letter-spacing: 4px;
            box-shadow: 0 0 15px #0ff; transition: all 0.2s;
        }
        .btn:hover { background: #0ff; color: #000; box-shadow: 0 0 50px #0ff; transform: scale(1.1); }

        #level-display {
            position: absolute; top: 20px; right: 40px; font-size: 2rem; color: #fff;
            text-shadow: 0 0 10px #f0f; display: none;
        }

        #score-msg { font-size: 1.2rem; color: #888; margin-top: 10px; letter-spacing: 2px; }

        /* Glitch Animation */
        @keyframes glitch {
            0% { text-shadow: 2px 2px #f0f, -2px -2px #0ff; transform: skew(0deg); }
            20% { text-shadow: 2px 2px #f0f, -2px -2px #0ff; transform: skew(0deg); }
            21% { text-shadow: -2px 2px #f0f, 2px -2px #0ff; transform: skew(10deg); }
            22% { text-shadow: 2px -2px #f0f, -2px 2px #0ff; transform: skew(0deg); }
            100% { text-shadow: 2px 2px #f0f, -2px -2px #0ff; }
        }

        .overlay { background: rgba(0,0,0,0.8); width: 100%; height: 100%; position: absolute; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .hidden { opacity: 0; pointer-events: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div id="start-screen" class="overlay">
            <h1>ＳＩＭＯＮ<br>ＲＥＢＯＲＮ</h1>
            <p id="score-msg">AURAL // VISUAL // MEMORY</p>
            <button id="start-btn" class="btn">INITIALIZE</button>
        </div>
        <div id="game-over-screen" class="overlay hidden">
            <h1>NEURAL<br>OVERLOAD</h1>
            <p id="final-score" style="font-size: 2rem; color: #f0f;">LEVEL: 0</p>
            <button id="retry-btn" class="btn">REBOOT SYSTEM</button>
        </div>
        <div id="level-display">LVL <span id="lvl-val">1</span></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // --- 1. CONFIGURATION & STATE ---
        const CONFIG = {
            colors: [0xff0055, 0x00aaff, 0x00ff00, 0xffaa00], // Magenta, Cyan, Green, Amber
            baseFreqs: [130.81, 196.00, 164.81, 220.00], // C3, G3, E3, A3 (Pentatonic-ish)
            bloomStrength: 2.5,
            bloomRadius: 0.8,
            bloomThreshold: 0.1
        };

        const STATE = {
            isPlaying: false,
            isComputerTurn: false,
            sequence: [],
            playerIndex: 0,
            level: 1,
            time: 0,
            orbs: [], // Holds mesh references
            particles: [], // Explosion systems
        };

        // --- 2. AUDIO SYSTEM (Web Audio API - No external files) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playTone(index, duration = 0.5) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            // Frequency setup
            const freq = CONFIG.baseFreqs[index % 4] * (1 + Math.floor(STATE.level / 8) * 0.5); // Pitch shift higher levels
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            
            // Filter envelope (Lowpass sweep for that "Bass" feel)
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(100, audioCtx.currentTime);
            filter.frequency.exponentialRampToValueAtTime(8000, audioCtx.currentTime + 0.1);
            filter.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + duration);

            // Gain envelope
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

            // Sub-bass layer
            const subOsc = audioCtx.createOscillator();
            const subGain = audioCtx.createGain();
            subOsc.type = 'sine';
            subOsc.frequency.setValueAtTime(freq / 2, audioCtx.currentTime);
            subGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            subGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration + 0.2);

            // Connect graph
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            subOsc.connect(subGain);
            subGain.connect(audioCtx.destination);

            osc.start();
            subOsc.start();
            osc.stop(audioCtx.currentTime + duration + 0.2);
            subOsc.stop(audioCtx.currentTime + duration + 0.2);
        }

        function playErrorSound() {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.5);
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        }

        // --- 3. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 4. SHADERS (GLSL) ---
        
        // 4.1 Background "Hyperspace" Particle Shader
        const starVertexShader = `
            uniform float time;
            uniform float warpFactor;
            attribute float size;
            varying vec3 vColor;
            void main() {
                vColor = color;
                vec3 pos = position;
                // Warp effect: stretch along Z and rotate
                float angle = time * 0.1 + pos.z * 0.02;
                float radius = length(pos.xy);
                
                pos.z += time * (5.0 + warpFactor * 20.0);
                pos.z = mod(pos.z, 100.0) - 50.0; // Infinite loop
                
                // Spiral distortion
                pos.x += cos(angle + pos.z * 0.1) * 2.0;
                pos.y += sin(angle + pos.z * 0.1) * 2.0;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = size * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const starFragmentShader = `
            varying vec3 vColor;
            void main() {
                // Soft circle particle
                float r = distance(gl_PointCoord, vec2(0.5));
                if (r > 0.5) discard;
                float glow = 1.0 - (r * 2.0);
                glow = pow(glow, 2.0);
                gl_FragColor = vec4(vColor, glow);
            }
        `;

        // 4.2 Orb "Black Hole" Shader
        const orbVertexShader = `
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const orbFragmentShader = `
            uniform vec3 color;
            uniform float activeState; // 0 to 1
            uniform float time;
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);
                
                // Fresnel Effect (Rim lighting)
                float fresnel = pow(1.0 - dot(viewDir, normal), 3.0);
                
                // Pulsating core
                float pulse = sin(time * 5.0) * 0.5 + 0.5;
                
                // Mix Black Hole center with Neon Rim
                vec3 baseColor = mix(vec3(0.0), color, fresnel + (activeState * 0.8));
                
                // Add "Activity" brightness
                baseColor += color * activeState * pulse * 2.0;

                gl_FragColor = vec4(baseColor, 1.0); // Additive blending handles transparency
            }
        `;

        // --- 5. OBJECT CREATION ---

        // Background Stars
        const starGeo = new THREE.BufferGeometry();
        const starCount = 15000;
        const starPos = [], starColors = [], starSizes = [];
        const colorPalette = [new THREE.Color('#00ffff'), new THREE.Color('#ff00ff'), new THREE.Color('#ffffff')];

        for(let i=0; i<starCount; i++) {
            starPos.push((Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100);
            const c = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            starColors.push(c.r, c.g, c.b);
            starSizes.push(Math.random() * 0.5 + 0.1);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        starGeo.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));

        const starMat = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 }, warpFactor: { value: 0 } },
            vertexShader: starVertexShader,
            fragmentShader: starFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // The Simon Orbs
        const orbsGroup = new THREE.Group();
        scene.add(orbsGroup);
        const orbGeometry = new THREE.IcosahedronGeometry(2, 10);
        
        CONFIG.colors.forEach((col, i) => {
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(col) },
                    activeState: { value: 0.0 },
                    time: { value: 0 }
                },
                vertexShader: orbVertexShader,
                fragmentShader: orbFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const mesh = new THREE.Mesh(orbGeometry, material);
            // Position in a square/circle layout
            const angle = (i / 4) * Math.PI * 2 + (Math.PI/4);
            const radius = 6;
            mesh.position.set(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
            mesh.userData = { id: i, originalScale: 1, baseColor: new THREE.Color(col) };
            
            STATE.orbs.push(mesh);
            orbsGroup.add(mesh);
        });

        // --- 6. VISUAL EFFECTS (Explosions) ---
        function createExplosion(color, position) {
            const count = 500;
            const geo = new THREE.BufferGeometry();
            const pos = [], vels = [];
            
            for(let i=0; i<count; i++) {
                pos.push(position.x, position.y, position.z);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const speed = Math.random() * 0.5 + 0.2;
                vels.push(
                    Math.sin(phi) * Math.cos(theta) * speed,
                    Math.sin(phi) * Math.sin(theta) * speed,
                    Math.cos(phi) * speed
                );
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            
            const mat = new THREE.PointsMaterial({
                color: color, size: 0.4, transparent: true, blending: THREE.AdditiveBlending,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png') // Using CDN texture
            });

            const points = new THREE.Points(geo, mat);
            points.userData = { velocities: vels, life: 1.0 };
            scene.add(points);
            STATE.particles.push(points);
        }

        // --- 7. POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;
        composer.addPass(bloomPass);

        // Custom "Film Grain + Chromatic Aberration" Shader Pass
        const effectShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "amount": { value: 0.005 },
                "time": { value: 0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float amount;
                uniform float time;
                varying vec2 vUv;

                float random(vec2 p) { return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453); }

                void main() {
                    // Chromatic Aberration
                    float r = texture2D(tDiffuse, vUv + vec2(amount, 0.0)).r;
                    float g = texture2D(tDiffuse, vUv).g;
                    float b = texture2D(tDiffuse, vUv - vec2(amount, 0.0)).b;
                    vec3 color = vec3(r, g, b);

                    // Film Grain
                    float noise = random(vUv * time) * 0.1;
                    color += noise;

                    // Vignette
                    float dist = distance(vUv, vec2(0.5));
                    color *= 1.0 - dist * 0.5;

                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };
        const effectPass = new ShaderPass(effectShader);
        composer.addPass(effectPass);

        // --- 8. INPUT HANDLING ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onInput(event) {
            event.preventDefault();
            if (!STATE.isPlaying || STATE.isComputerTurn) return;

            let clientX, clientY;
            if (event.changedTouches) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(STATE.orbs);

            if (intersects.length > 0) {
                const orb = intersects[0].object;
                activateOrb(orb.userData.id, true);
                
                // Check Logic
                if (orb.userData.id === STATE.sequence[STATE.playerIndex]) {
                    STATE.playerIndex++;
                    if (STATE.playerIndex >= STATE.sequence.length) {
                        STATE.isComputerTurn = true;
                        setTimeout(nextLevel, 1000);
                    }
                } else {
                    gameOver();
                }
            }
        }

        window.addEventListener('mousedown', onInput);
        window.addEventListener('touchstart', onInput, {passive: false});

        // --- 9. GAME LOGIC ---

        function activateOrb(index, isPlayer) {
            const orb = STATE.orbs[index];
            orb.material.uniforms.activeState.value = 1.0;
            
            // Visual pop
            orb.scale.setScalar(2.5); 
            
            // Audio
            playTone(index);

            // Explosion
            createExplosion(orb.userData.baseColor, orb.position);

            // Camera shake
            if(isPlayer) camera.position.x += (Math.random()-0.5) * 0.5;
        }

        function nextLevel() {
            STATE.level++;
            document.getElementById('lvl-val').innerText = STATE.level;
            STATE.playerIndex = 0;
            STATE.isComputerTurn = true;

            // Difficulty ramping
            let speed = Math.max(200, 800 - (STATE.level * 30));
            if (STATE.level > 15) {
                starMat.uniforms.warpFactor.value = 1.0; // Warp speed
            } else {
                starMat.uniforms.warpFactor.value = 0.0;
            }

            // Add new step
            STATE.sequence.push(Math.floor(Math.random() * 4));

            // Play sequence
            let i = 0;
            const interval = setInterval(() => {
                activateOrb(STATE.sequence[i], false);
                i++;
                if (i >= STATE.sequence.length) {
                    clearInterval(interval);
                    STATE.isComputerTurn = false;
                }
            }, speed);
        }

        function startGame() {
            STATE.sequence = [];
            STATE.level = 0;
            STATE.isPlaying = true;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('level-display').style.display = 'block';
            
            // Reset rotation
            orbsGroup.rotation.z = 0;
            
            // Init audio context on first user gesture
            if(audioCtx.state === 'suspended') audioCtx.resume();

            nextLevel();
        }

        function gameOver() {
            STATE.isPlaying = false;
            playErrorSound();
            
            // Visual overload
            bloomPass.strength = 10.0;
            setTimeout(() => { bloomPass.strength = CONFIG.bloomStrength; }, 500);

            document.getElementById('final-score').innerText = "LEVEL: " + STATE.level;
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('level-display').style.display = 'none';
        }

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('retry-btn').addEventListener('click', startGame);

        // --- 10. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            STATE.time += delta;

            // Update Uniforms
            starMat.uniforms.time.value = STATE.time;
            effectPass.uniforms.time.value = STATE.time;
            effectPass.uniforms.amount.value = 0.002 + (STATE.level > 10 ? 0.005 : 0); // Increase glitch on higher levels

            // Rotate Orbs Group (Level 8+ difficulty)
            if (STATE.isPlaying && STATE.level >= 8) {
                orbsGroup.rotation.z += delta * 0.2;
            }

            // Update Orbs
            STATE.orbs.forEach(orb => {
                orb.material.uniforms.time.value = STATE.time;
                // Decay active state
                orb.material.uniforms.activeState.value *= 0.9;
                // Elastic scale return
                orb.scale.lerp(new THREE.Vector3(2, 2, 2), 0.1);
            });

            // Update Particles
            for (let i = STATE.particles.length - 1; i >= 0; i--) {
                const p = STATE.particles[i];
                p.userData.life -= delta;
                const positions = p.geometry.attributes.position.array;
                
                for (let j = 0; j < p.userData.velocities.length / 3; j++) {
                    positions[j*3] += p.userData.velocities[j*3];
                    positions[j*3+1] += p.userData.velocities[j*3+1];
                    positions[j*3+2] += p.userData.velocities[j*3+2];
                }
                p.geometry.attributes.position.needsUpdate = true;
                p.material.opacity = p.userData.life;

                if (p.userData.life <= 0) {
                    scene.remove(p);
                    p.geometry.dispose();
                    p.material.dispose();
                    STATE.particles.splice(i, 1);
                }
            }

            // Camera Idle Movement
            if (!STATE.isPlaying || !STATE.isComputerTurn) {
                camera.position.x += (Math.sin(STATE.time * 0.5) * 0.01);
                camera.position.y += (Math.cos(STATE.time * 0.3) * 0.01);
                camera.lookAt(0,0,0);
            }

            composer.render();
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
